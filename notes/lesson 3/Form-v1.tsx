import './Form.scss';

import { useState } from 'react';

// * 8.0 А теперь реализуем добавление новых тудушек через форму. Здесь нам нужно обработать событие "submit" на форме, а также ввод текста в input.
// 8.1 Для активации функции formSubmit мы повесим старым способом записи обработчик события onSubmit(). На самом деле React сделает из них уже современный синтаксис, но так как здесь у нас TSX, то используем такой синтаксис.
// 8.2 Также нам потребуется введённый текст сохранять в какую-то переменную, например "newTodoText" и изначально в ней будет пустая строка.
// 8.3 Создадим ещё одну функцию changeText() и повесим её на событие "input" на строку ввода. Однако эта функция должна будет также принимать объект события. И у нас сразу же выскочила ошибка, потому, что нам нужно было ещё указать тип события. И для строки ввода он будет другим, чем по умолчанию. Такой синтаксис в TS называется "Generic Type", подробнее в ссылках к уроку. Также необходимо теперь импортировать React.
// 8.4 Далее нужно передавать значение строки ввода в переменную newTodoText.
// 8.5 Теперь на основании содержимого переменной newTodoText нужно создавать новый объект, который будет добавляться в массив todos, где свойство "isDone" будет изначально false, а "id" будет +1 от предыдущего.
// todo ==> [переход в ToDoListPage.tsx]
// todo ==> [переход из ToDoListPage.tsx]
// 8.7 Теперь примем этот аргумент внутри компонента через добавление объекта props типа объект со свойство createNewToDo типа Function.
// 8.8 Далее мы вызовем эту функцию в функции formSubmit() и передадим туда newTodoText, однако только в случае, если newTodoText содержит только пустую строку.
// 8.9 Также, после того, как пользователь добавит новую тудушку, поле необходимо очищать. Но просто присвоить пустую строку переменной не подходит, и здесь нам пригодятся уже хуки react, а именно "useState".
// 8.10 Итак, функция useState() служит хранилищем состояния и управления им. "text" это переменная, которая хранит то значение, которое изначально передали, а "setText" — это метод изменения переменной "text". Т.е. изначально в "text" попадает значение, которые передаём в useState().
// 8.11 Далее в <input> мы "onInput" заменим на "onChange" и мы будем вызывать коллбэк-функцию, которая будет принимать event и вызывать setText(), которая примет аргументом значение строки ввода через "evt.target.value".
// 8.12 Теперь в formSubmit() мы будет проверять не newTodoText, а text и отправлять тоже text, а функция changeText() и вовсе больше стала не нужна, как и переменная newTodoText.
// 8.13 А чтобы почистить строку ввода мы просто запустим внутри formSubmit() setText() с пустой строкой внутри, а в <input> добавим атрибут value, который будет принимать text.
// 8.14 Также нам нужно типизировать, для этого после useState добавим <>, куда вставим string.
// todo ==> [переход в ToDoListPage.tsx]
export const Form = (props: { createNewToDo: Function }) => {
  const [text, setText] = useState<string>('');

  // let newTodoText = '';

  const formSubmit = () => {
    /* 		if (newTodoText) {
			props.createNewToDo(newTodoText);
		} */

    if (text) {
      props.createNewToDo(text);
      setText('');
    }
  };

  /* 	const changeText = (evt: React.ChangeEvent<HTMLInputElement>) => {
		newTodoText = evt.target.value;
	} */

  return (
    <div className="form-wrapper">
      <form action="#" onSubmit={formSubmit}>
        <label>
          {/* <input type="text" onInput={changeText} /> */}
          <input
            value={text}
            type="text"
            onChange={(evt) => setText(evt.target.value)}
          />
          <button></button>
        </label>
      </form>
    </div>
  );
};
